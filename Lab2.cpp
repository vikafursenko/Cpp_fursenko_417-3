
#include <iostream>
#include <locale.h>
#include <iomanip>
#include <bitset>

// КОНСТРУКЦИИ ЯЗЫКА C/C++

int main()
{
	setlocale(LC_ALL, "Russian");

	// 1. Условные переходы

	// 1.1 Оператор if и if...else...



	int salary = 120000;
	bool has_education = true;
	if ((salary < 150000) /*=true*/ && has_education /*в скобках должна быть логическая переменная или условие, выдающее true или false*/)
	{
		std::cout << "Зашли под if!" << std::endl;
		// всё, что внутри скобок if выполняется если условие в круглых скобках равно true
	}



	std::string name;
	std::cout << "Введите ваше имя:";
	std::cin >> name;
	if (name == "Иван" /*false= если имя не равно "Иван"*/)
	{
		std::cout << "Зашли под второй if!" << std::endl;
	}
	else
	{
		std::cout << "Зашли под else!" << std::endl;
	}



	// 1.2 Оператор switch...case...default

	int type_of_creditor; // 1 = "physical"
	// 2 = "small_business"
	// 3 = "medium_business"
	// 4 = "large_business"

	// !!! прописать ввод цифры - кода клиента здесь в type_of_creditor
	std::cin >> type_of_creditor;
	switch (type_of_creditor/*переменная, которая подлежит сравнению*/)
	{
	case 1/*physical*/:
		std::cout << "Тип клиента - physical" << std::endl;
		break;
	case 2/*small_business*/:
		std::cout << "Тип клиента - small_business" << std::endl;
		break;
	case 3/*medium_business*/:
		std::cout << "Тип клиента - medium_business" << std::endl;
		break;
	case 4/*large_business*/:
		std::cout << "Тип клиента - large_business" << std::endl;
		break;
	default: // действия, которые выполняются во всех прочих случаях
		break;
	}

	// 1.3 Тернарный оператор
	int c = 10;
	// кратко условный пререход можно даже записать в одну строку if (c < 5) {} else {}
	// или в виде тернарного оператора (/*условие*/)?(/*ветка если условние ==true*/):(/*ветка елси false*/)
	// как и if, его можно употреблять без второй ветки ( без else или без :)
	(c < 5)
		? (std::cout << " Тернарный оператор true" << std::endl /*операторы, если true*/)
		: (std::cout << " Тернарный оператор false" << std::endl /*операторы, если false*/);
	// 1.4 Оператор без безусловоного перехода goto
	// в современной обработке стараются не применять, т.к. это как минимум уменьшает читаемость кода
	// синтаксис:
	// в нужном месте программы создается т.н. метка
/* lbl_1: // идентификатор названия if и : - это явление метки
  *	c++;
  * std::cout << "1.4. Демонстрация goto. c=" << c << std::endl;
	   goto lbl_1; */


	   // ЗАДАНИЕ: НАПИСАТЬ КОД, ЧТОБЫ ПРИ С==15 ВЫПОЛНЯЛСЯ ВЫХОД БЕЗ БЕСКОНЕЧНОГО ЦИКЛА НА lbl_exit

lbl_1:
	c++;
	std::cout << "1.4. Демонстрация goto. c=" << c << std::endl;
	if (c == 15) { goto lbl_exit; }
	goto lbl_1;
lbl_exit:
	std::cout << "Вышли из цикла goto" << std::endl;

	// ДЗ заполнить циклы соответсвующим выводом консоль по аналогии с прочим материалом 

// 2. Конструкции цикла
// 2.1 Счётный цикл for и операторы continue и break
	for (int i = 0 /*начальное значение переменной-счетчика*/;
		i < 7; /*условие продолжения, пока оно true - цикл продолжается*/)
		i++ /*повторяющийся оператор, чаще всего - уменьшение или увеличение счетчика*/)
	{
	 //.. код, который нужно повторять, пока длится цикл (пока длится условие продолжения)
	 // заполнить распечаткой самостоятельно к 7 октября
    }
	// 2.2 Цикл с пред-условием while
	while (// задание: придумать и прописать условие /*условие, пока оно == true, цикл выполняется*/)
		{
			//.. код, который нужно повторять, пока длится цикл (пока длится условие продолжения)
	 // заполнить распечаткой самостоятельно к 15 октября
		}

	// 2.3 Цикл с пост-условием do...while
		// самый первый заход в цикл выполяется всегда (т.к. проверка условия выполняется после тела цикла)
		do {
			//.. код, который нужно повторять, пока длится цикл (пока длится условие продолжения)
	 // заполнить распечаткой самостоятельно к 15 октября
		} while (// задание: придумать и прописать условие /*условие, пока оно == true, цикл выполняется*/)

// внутри граффический приложений и программ, которые работают продолжительное время, и не заверщшаются сами собой, как 

   /* Основы GIT:
   Cсылка: https://git-scm.com/ 
   
   другие СКВ: GIT, Mercurial, SVN и др.
   
   если кратко: как только разработчику необходимо сделать "снимок" текущих файлов своего проекта (версию),
   он вводит в GIT команду и GIT - вместо простого копирования папок и файлов, определяет изменение текущей версии файла,  
   относительно предыдущей, и записывает разницу таким образом git ведет историю версий всех файлов в очень компактной виде
   */


 
	std::system("pause"); // вызов функции system() из стандартной библиотеки
	return 0;
}
